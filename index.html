<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FaceScore</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
<style>
 body { background: #0b0f14; color: #e6edf3; }
 .card { background: #111827; border: 1px solid #1f2937; border-radius: 14px; }
 .btn { background: #2563eb; color: white; border-radius: 10px; padding: 10px 16px; font-weight: 600; }
 .btn:disabled { opacity: .6; }
 .metric { background: #0f172a; border: 1px solid #1e293b; border-radius: 10px; padding: 10px; }
 .score-badge { position: absolute; top: 12px; left: 12px; background: rgba(2,6,23,.72); border: 1px solid rgba(148,163,184,.35); backdrop-filter: blur(6px); padding: 8px 12px; border-radius: 10px; font-weight: 700; }
 canvas { max-width: 100%; height: auto; }
 .grid-col { display: grid; grid-template-columns: 1fr; gap: 16px; }
 @media (min-width: 1024px) { .grid-col { grid-template-columns: 1fr 420px; } }
</style>
<script src="https://unpkg.com/@tensorflow/tfjs-core@4.19.0/dist/tf-core.min.js"></script>
<script src="https://unpkg.com/@tensorflow/tfjs-converter@4.19.0/dist/tf-converter.min.js"></script>
<script src="https://unpkg.com/@tensorflow/tfjs-backend-webgl@4.19.0/dist/tf-backend-webgl.min.js"></script>
<script src="https://unpkg.com/@tensorflow/tfjs-backend-wasm@4.19.0/dist/tf-backend-wasm.min.js"></script>
<script src="https://unpkg.com/@tensorflow-models/face-landmarks-detection@1.0.5/dist/face-landmarks-detection.min.js"></script>
<script src="https://unpkg.com/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
<script async src="https://docs.opencv.org/4.10.0/opencv.js"></script>
</head>
<body>
<div class="max-w-7xl mx-auto p-6">
  <h1 class="text-2xl lg:text-3xl font-extrabold mb-6">FaceScore</h1>
  <div class="grid-col gap-6">
    <div class="card p-4 lg:p-6">
      <div class="flex flex-wrap items-center gap-3 mb-4">
        <input id="fileInput" type="file" accept="image/*" class="text-sm" title="Görsel seç (Ctrl+O)" />
        <button id="analyzeBtn" class="btn" disabled title="Görseli analiz et (A)">Analiz Et</button>
        <button id="startCamBtn" class="btn" title="Kamerayı başlat (Space)">Kamera</button>
        <button id="stopCamBtn" class="btn" disabled title="Kamerayı durdur (Space)">Durdur</button>
        <label class="flex items-center gap-2 text-sm text-gray-300 ml-2" title="Webcam görüntüsünü aynala">
          <input id="mirrorChk" type="checkbox" class="form-checkbox"> Ayna
        </label>
        <span id="status" class="text-sm text-gray-300"></span>
      </div>
      <div id="dropZone" class="mb-4 p-4 border-2 border-dashed border-gray-600 rounded-lg text-gray-300 text-sm">
        Görseli buraya sürükleyip bırakın veya dosya seçin. Canlı analiz için Kamera’ya basın.
      </div>
      <div class="relative w-full overflow-auto">
        <div id="scoreBadge" class="score-badge hidden">Skor: <span id="scoreText">-</span></div>
        <canvas id="canvas" class="w-full"></canvas>
        <video id="video" class="hidden" autoplay playsinline muted></video>
      </div>
    </div>
    <div class="card p-4 lg:p-6">
      <h2 class="text-xl font-bold mb-3">Metri̇kler ve Yüz Listesi</h2>
      <div class="mb-4 space-y-2">
        <div class="flex flex-wrap items-center gap-2">
          <label class="text-sm text-gray-300">Profil</label>
          <select id="profileSelect" class="bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm"></select>
          <button id="newProfileBtn" class="btn text-sm px-3 py-2">Yeni</button>
          <button id="saveProfileBtn" class="btn text-sm px-3 py-2">Kaydet</button>
          <button id="deleteProfileBtn" class="btn text-sm px-3 py-2">Sil</button>
        </div>
        <details id="profileDetails" class="bg-gray-900 border border-gray-800 rounded p-3">
          <summary class="cursor-pointer select-none text-sm text-gray-200 mb-2">Profil Hedefleri ve Ağırlıklar</summary>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-3 mt-2">
            <div>
              <label class="block text-xs text-gray-400 mb-1">Ad</label>
              <input id="profileName" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" placeholder="Profil adı" />
            </div>
            <div class="flex items-end">
              <button id="fillFromFaceBtn" class="btn text-sm px-3 py-2">Aktif yüzden hedefleri doldur</button>
            </div>
          </div>
          <div class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3">
            <div class="metric">
              <div class="text-xs text-gray-300">Orantı Hedefi (H/G)</div>
              <input id="t_ratio" type="number" step="0.001" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
              <div class="mt-2 text-xs text-gray-400">Ağırlık</div>
              <input id="w_ratio" type="number" step="0.01" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
            </div>
            <div class="metric">
              <div class="text-xs text-gray-300">Göz/Yüz Genişliği Hedefi</div>
              <input id="t_eye" type="number" step="0.001" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
              <div class="mt-2 text-xs text-gray-400">Ağırlık</div>
              <input id="w_eye" type="number" step="0.01" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
            </div>
            <div class="metric">
              <div class="text-xs text-gray-300">Burun/Yüz Yüksekliği Hedefi</div>
              <input id="t_nose" type="number" step="0.001" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
              <div class="mt-2 text-xs text-gray-400">Ağırlık</div>
              <input id="w_nose" type="number" step="0.01" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
            </div>
            <div class="metric">
              <div class="text-xs text-gray-300">Simetri (hedef 1.0)</div>
              <input id="t_sym" type="number" step="0.01" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
              <div class="mt-2 text-xs text-gray-400">Ağırlık</div>
              <input id="w_sym" type="number" step="0.01" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
            </div>
            <div class="metric">
              <div class="text-xs text-gray-300">Ağız/Yüz Genişliği Hedefi</div>
              <input id="t_mouth" type="number" step="0.001" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
              <div class="mt-2 text-xs text-gray-400">Ağırlık</div>
              <input id="w_mouth" type="number" step="0.01" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
            </div>
            <div class="metric">
              <div class="text-xs text-gray-300">Interpupiller/Yüz Genişliği</div>
              <input id="t_ipd" type="number" step="0.001" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
              <div class="mt-2 text-xs text-gray-400">Ağırlık</div>
              <input id="w_ipd" type="number" step="0.01" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
            </div>
            <div class="metric">
              <div class="text-xs text-gray-300">EAR (Göz açıklığı)</div>
              <input id="t_ear" type="number" step="0.001" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
              <div class="mt-2 text-xs text-gray-400">Ağırlık</div>
              <input id="w_ear" type="number" step="0.01" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
            </div>
            <div class="metric">
              <div class="text-xs text-gray-300">İris/Göz Genişliği</div>
              <input id="t_irisEye" type="number" step="0.001" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
              <div class="mt-2 text-xs text-gray-400">Ağırlık</div>
              <input id="w_irisEye" type="number" step="0.01" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
            </div>
            <div class="metric">
              <div class="text-xs text-gray-300">İris/Yüz Genişliği</div>
              <input id="t_irisFace" type="number" step="0.001" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
              <div class="mt-2 text-xs text-gray-400">Ağırlık</div>
              <input id="w_irisFace" type="number" step="0.01" class="w-full bg-gray-800 border border-gray-700 rounded px-2 py-1 text-sm" />
            </div>
          </div>
          <div class="mt-3 flex flex-wrap gap-2">
            <button id="applyProfileBtn" class="btn text-sm px-3 py-2">Uygula ve Yeniden Puanla</button>
          </div>
        </details>
      </div>
      <div id="facesContainer" class="space-y-3 mb-4"></div>
      <div class="space-y-3">
        <div class="metric"><div class="text-sm text-gray-300">Orantı (Yükseklik/Genişlik)</div><div id="ratioMetric" class="text-lg font-semibold">-</div></div>
        <div class="metric"><div class="text-sm text-gray-300">Göz Oranı (Göz arası / Yüz genişliği)</div><div id="eyeMetric" class="text-lg font-semibold">-</div></div>
        <div class="metric"><div class="text-sm text-gray-300">Burun Oranı (Burun / Yüz yüksekliği)</div><div id="noseMetric" class="text-lg font-semibold">-</div></div>
        <div class="metric"><div class="text-sm text-gray-300">Simetri</div><div id="symmetryMetric" class="text-lg font-semibold">-</div></div>
        <div class="metric"><div class="text-sm text-gray-300">Ağız Genişliği / Yüz Genişliği</div><div id="mouthMetric" class="text-lg font-semibold">-</div></div>
        <div class="metric"><div class="text-sm text-gray-300">Interpupiller / Yüz Genişliği</div><div id="ipdMetric" class="text-lg font-semibold">-</div></div>
        <div class="metric"><div class="text-sm text-gray-300">Göz Açıklığı (Sol/Sağ EAR)</div><div id="earMetric" class="text-lg font-semibold">-</div></div>
        <div class="metric"><div class="text-sm text-gray-300">İris Çapı / Göz Genişliği</div><div id="irisEyeMetric" class="text-lg font-semibold">-</div></div>
        <div class="metric"><div class="text-sm text-gray-300">İris Çapı / Yüz Genişliği</div><div id="irisFaceMetric" class="text-lg font-semibold">-</div></div>
        <div class="metric"><div class="text-sm text-gray-300">Keskinlik (Bulanıklık)</div><div id="blurMetric" class="text-lg font-semibold">-</div></div>
        <div class="metric"><div class="text-sm text-gray-300">Baş Eğim Açısı (°)</div><div id="tiltMetric" class="text-lg font-semibold">-</div></div>
      </div>
    </div>
  </div>
</div>
<script>
let model; // facemesh
let blazeModel; // blazeface fallback
let imgBitmap;
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const fileInput = document.getElementById('fileInput');
const analyzeBtn = document.getElementById('analyzeBtn');
const statusEl = document.getElementById('status');
const scoreBadge = document.getElementById('scoreBadge');
const scoreText = document.getElementById('scoreText');
const ratioMetric = document.getElementById('ratioMetric');
const eyeMetric = document.getElementById('eyeMetric');
const noseMetric = document.getElementById('noseMetric');
const symmetryMetric = document.getElementById('symmetryMetric');
const mouthMetric = document.getElementById('mouthMetric');
const ipdMetric = document.getElementById('ipdMetric');
const earMetric = document.getElementById('earMetric');
const irisEyeMetric = document.getElementById('irisEyeMetric');
const irisFaceMetric = document.getElementById('irisFaceMetric');
const blurMetric = document.getElementById('blurMetric');
const tiltMetric = document.getElementById('tiltMetric');
const facesContainer = document.getElementById('facesContainer');
const dropZone = document.getElementById('dropZone');
const video = document.getElementById('video');
const startCamBtn = document.getElementById('startCamBtn');
const stopCamBtn = document.getElementById('stopCamBtn');
const mirrorChk = document.getElementById('mirrorChk');
const profileSelect = document.getElementById('profileSelect');
const newProfileBtn = document.getElementById('newProfileBtn');
const saveProfileBtn = document.getElementById('saveProfileBtn');
const deleteProfileBtn = document.getElementById('deleteProfileBtn');
const profileName = document.getElementById('profileName');
const t_ratio = document.getElementById('t_ratio');
const w_ratio = document.getElementById('w_ratio');
const t_eye = document.getElementById('t_eye');
const w_eye = document.getElementById('w_eye');
const t_nose = document.getElementById('t_nose');
const w_nose = document.getElementById('w_nose');
const t_sym = document.getElementById('t_sym');
const w_sym = document.getElementById('w_sym');
const t_mouth = document.getElementById('t_mouth');
const w_mouth = document.getElementById('w_mouth');
const t_ipd = document.getElementById('t_ipd');
const w_ipd = document.getElementById('w_ipd');
const t_ear = document.getElementById('t_ear');
const w_ear = document.getElementById('w_ear');
const t_irisEye = document.getElementById('t_irisEye');
const w_irisEye = document.getElementById('w_irisEye');
const t_irisFace = document.getElementById('t_irisFace');
const w_irisFace = document.getElementById('w_irisFace');
const fillFromFaceBtn = document.getElementById('fillFromFaceBtn');
const applyProfileBtn = document.getElementById('applyProfileBtn');

let live = false;
let mediaStream = null;
let rafId = null;
let selectedFace = 0;
let lastPredictions = [];
let cvReady = false; let faceClassifier = null;
let lastQuality = { blurVar: null, blurScore: null };

const defaultProfile = {
  id: 'default',
  name: 'Varsayılan',
  targets: { ratio: 1.618, eye: 0.46, nose: 0.33, sym: 1.0, mouth: 0.36, ipd: 0.32, ear: 0.30, irisEye: 0.32, irisFace: 0.095 },
  weights: { ratio: .2, eye: .16, nose: .12, sym: .2, mouth: .10, ipd: .06, ear: .04, irisEye: .07, irisFace: .05 }
};
let profiles = [];
let activeProfileId = 'default';

function loadProfiles(){
  try{
    const s = localStorage.getItem('facescore_profiles');
    const a = s ? JSON.parse(s) : [];
    profiles = [defaultProfile, ...a.filter(p=>p.id!=='default')];
  }catch(e){ profiles = [defaultProfile]; }
  const aid = localStorage.getItem('facescore_active') || 'default';
  activeProfileId = profiles.find(p=>p.id===aid)? aid : 'default';
  renderProfileSelect();
  applyProfileToForm();
}
function saveProfiles(){
  const a = profiles.filter(p=>p.id!=='default');
  try{ localStorage.setItem('facescore_profiles', JSON.stringify(a)); }catch(e){}
  try{ localStorage.setItem('facescore_active', activeProfileId); }catch(e){}
}
function renderProfileSelect(){
  profileSelect.innerHTML='';
  profiles.forEach(p=>{
    const opt = document.createElement('option');
    opt.value = p.id; opt.textContent = p.name+(p.id==='default'?' (varsayılan)':'');
    if (p.id===activeProfileId) opt.selected = true;
    profileSelect.appendChild(opt);
  });
}
function getActiveProfile(){ return profiles.find(p=>p.id===activeProfileId) || defaultProfile; }
function applyProfileToForm(){
  const p = getActiveProfile();
  profileName.value = p.name || '';
  t_ratio.value = p.targets.ratio; w_ratio.value = p.weights.ratio;
  t_eye.value = p.targets.eye; w_eye.value = p.weights.eye;
  t_nose.value = p.targets.nose; w_nose.value = p.weights.nose;
  t_sym.value = p.targets.sym; w_sym.value = p.weights.sym;
  t_mouth.value = p.targets.mouth; w_mouth.value = p.weights.mouth;
  t_ipd.value = p.targets.ipd; w_ipd.value = p.weights.ipd;
  t_ear.value = p.targets.ear; w_ear.value = p.weights.ear;
  t_irisEye.value = p.targets.irisEye; w_irisEye.value = p.weights.irisEye;
  t_irisFace.value = p.targets.irisFace; w_irisFace.value = p.weights.irisFace;
}
function formToProfile(p){
  p.name = profileName.value || p.name || 'Profil';
  p.targets = {
    ratio: parseFloat(t_ratio.value)||0,
    eye: parseFloat(t_eye.value)||0,
    nose: parseFloat(t_nose.value)||0,
    sym: parseFloat(t_sym.value)||1,
    mouth: parseFloat(t_mouth.value)||0,
    ipd: parseFloat(t_ipd.value)||0,
    ear: parseFloat(t_ear.value)||0,
    irisEye: parseFloat(t_irisEye.value)||0,
    irisFace: parseFloat(t_irisFace.value)||0
  };
  p.weights = {
    ratio: parseFloat(w_ratio.value)||0,
    eye: parseFloat(w_eye.value)||0,
    nose: parseFloat(w_nose.value)||0,
    sym: parseFloat(w_sym.value)||0,
    mouth: parseFloat(w_mouth.value)||0,
    ipd: parseFloat(w_ipd.value)||0,
    ear: parseFloat(w_ear.value)||0,
    irisEye: parseFloat(w_irisEye.value)||0,
    irisFace: parseFloat(w_irisFace.value)||0
  };
}
profileSelect?.addEventListener('change', ()=>{
  activeProfileId = profileSelect.value;
  saveProfiles();
  applyProfileToForm();
});
newProfileBtn?.addEventListener('click', ()=>{
  const id = 'p_'+Math.random().toString(36).slice(2,8);
  const base = JSON.parse(JSON.stringify(getActiveProfile()));
  base.id = id; base.name = 'Yeni Profil';
  profiles.push(base);
  activeProfileId = id;
  renderProfileSelect();
  applyProfileToForm();
  saveProfiles();
});
saveProfileBtn?.addEventListener('click', ()=>{
  const p = getActiveProfile();
  formToProfile(p);
  renderProfileSelect();
  saveProfiles();
});
deleteProfileBtn?.addEventListener('click', ()=>{
  if (activeProfileId==='default') return;
  profiles = profiles.filter(p=>p.id!==activeProfileId);
  activeProfileId = 'default';
  renderProfileSelect();
  applyProfileToForm();
  saveProfiles();
});
fillFromFaceBtn?.addEventListener('click', ()=>{
  const last = window.__lastMetricsList && window.__lastMetricsList[selectedFace];
  if (!last) return;
  if (last.ratioVal!== '-') t_ratio.value = parseFloat(last.ratioVal);
  if (last.eyeVal!== '-') t_eye.value = parseFloat(last.eyeVal);
  if (last.noseVal!== '-') t_nose.value = parseFloat(last.noseVal);
  t_sym.value = 1.0;
  if (last.mouthVal!== '-') t_mouth.value = parseFloat(last.mouthVal);
  if (last.ipdVal!== '-') t_ipd.value = parseFloat(last.ipdVal);
  const earAvg = (last.leftEAR && last.rightEAR)? ((last.leftEAR+last.rightEAR)/2) : null;
  if (earAvg) t_ear.value = parseFloat(earAvg.toFixed(3));
  if (last.irisEyeVal!== '-') t_irisEye.value = parseFloat(last.irisEyeVal);
  if (last.irisFaceVal!== '-') t_irisFace.value = parseFloat(last.irisFaceVal);
});
applyProfileBtn?.addEventListener('click', async ()=>{
  const p = getActiveProfile();
  formToProfile(p);
  saveProfiles();
  if (live) return;
  if (canvas.width>0 && canvas.height>0) await analyzeOnce(canvas);
});

function setStatus(t){ statusEl.textContent = t || ''; }
function drawCircle(p, r, color){ ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fillStyle=color; ctx.fill(); }
function drawLine(a,b,color,w){ ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.strokeStyle=color; ctx.lineWidth=w; ctx.stroke(); }
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function closenessScore(v, target, tol){ const d = Math.abs(v-target); const s = clamp(1 - d/tol, 0, 1); return s; }

async function enhanceInput(input){
  try{
    const w = (input===video)? (video.videoWidth||canvas.width||0) : canvas.width;
    const h = (input===video)? (video.videoHeight||canvas.height||0) : canvas.height;
    if (!w || !h) return null;
    const off = document.createElement('canvas'); off.width=w; off.height=h;
    const ox = off.getContext('2d');
    const mirrored = (input===video && mirrorChk && mirrorChk.checked);
    if (mirrored){ ox.translate(w,0); ox.scale(-1,1); }
    ox.drawImage(input,0,0,w,h);
    if (cvReady){
      let src = cv.imread(off);
      let gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
      let den = new cv.Mat(); cv.bilateralFilter(gray, den, 5, 50, 50);
      let sharp = new cv.Mat();
      let ga = new cv.Mat(); cv.GaussianBlur(den, ga, new cv.Size(0,0), 1.0);
      cv.addWeighted(den, 1.6, ga, -0.6, 0, sharp);
      let clahe = cv.createCLAHE(2.0, new cv.Size(8,8));
      let eq = new cv.Mat(); clahe.apply(sharp, eq); clahe.delete();
      cv.cvtColor(eq, src, cv.COLOR_GRAY2RGBA);
      cv.imshow(off, src);
      gray.delete(); den.delete(); ga.delete(); sharp.delete(); eq.delete(); src.delete();
    }
    return off;
  }catch(e){ return null; }
}

async function ensureModels(){
  if (model || blazeModel) return;
  setStatus('Modeller yükleniyor...');
  try { await tf.ready(); } catch(e) {}
  try { if (tf.wasm && tf.wasm.setWasmPaths) { tf.wasm.setWasmPaths('https://unpkg.com/@tensorflow/tfjs-backend-wasm@4.19.0/dist/'); } } catch(e) {}
  const backends = ['webgl','wasm','cpu'];
  for (const b of backends){ try { await tf.setBackend(b); await tf.ready(); break; } catch(e){} }
  // try facemesh
  try{
    model = await faceLandmarksDetection.load(
      faceLandmarksDetection.SupportedPackages.mediapipeFacemesh,
      { maxFaces: 5, shouldLoadIrisModel: true }
    );
  }catch(e){ model = null; }
  // load blazeface as fallback
  try{ blazeModel = await blazeface.load(); }catch(e){ blazeModel = null; }
  if (!model && !blazeModel){ setStatus('Model yüklenemedi'); throw new Error('No models loaded'); }
  setStatus('');
}

// OpenCV init helpers
async function tryInitOpenCV(){
  if (cvReady) return true;
  if (!window.cv) return false;
  try {
    if (!faceClassifier){
      const url = 'https://cdn.jsdelivr.net/gh/opencv/opencv@4.10.0/data/haarcascades/haarcascade_frontalface_default.xml';
      const resp = await fetch(url); const buf = await resp.arrayBuffer();
      if (cv.FS && cv.FS_createDataFile){
        try { if (!cv.FS_lookupPath('/haarcascade_frontalface_default.xml').node) { /* pass */ } } catch(e) {
          cv.FS_createDataFile('/', 'haarcascade_frontalface_default.xml', new Uint8Array(buf), true, false, false);
        }
      }
      faceClassifier = new cv.CascadeClassifier();
      faceClassifier.load('haarcascade_frontalface_default.xml');
    }
    cvReady = true; return true;
  } catch(e){ return false; }
}

let cvInitTimer = null;
function scheduleCvInit(){
  if (cvInitTimer) return;
  cvInitTimer = setInterval(async ()=>{
    const ok = await tryInitOpenCV();
    if (ok){ clearInterval(cvInitTimer); cvInitTimer = null; }
  }, 400);
}

if (window.cv) {
  if (cv.onRuntimeInitialized) cv.onRuntimeInitialized = scheduleCvInit; else scheduleCvInit();
} else {
  window.addEventListener('opencvready', scheduleCvInit);
}

function resetUIForImage(img){
  // downscale very large images for stability/performance
  const maxSide = 1400;
  let w = img.width, h = img.height;
  if (Math.max(w,h) > maxSide){
    const scale = maxSide/Math.max(w,h);
    w = Math.round(w*scale); h = Math.round(h*scale);
    const off = document.createElement('canvas'); off.width=w; off.height=h;
    const ox = off.getContext('2d'); ox.drawImage(img,0,0,w,h);
    const resized = new Image(); resized.src = off.toDataURL('image/jpeg', 0.92);
    imgBitmap = resized; // use resized as analysis input
    canvas.width = w; canvas.height = h;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    resized.onload = ()=>{ ctx.drawImage(resized,0,0,w,h); };
  } else {
    imgBitmap = img;
    canvas.width = w; canvas.height = h;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,0,0,canvas.width,canvas.height);
    // Apply OpenCV-based preprocessing (denoise, unsharp, CLAHE)
    if (cvReady) {
      const mat = cv.imread(canvas);
      cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(mat, mat, new cv.Size(3, 3), 0);
      cv.convertScaleAbs(mat, mat, 1.5, 0);
      cv.applyCLAHE(mat, mat, 2.0, new cv.Size(8, 8));
      cv.imshow(canvas, mat);
      mat.delete();
    }
  }
  scoreBadge.classList.add('hidden');
  scoreText.textContent='-';
  analyzeBtn.disabled = false;
  facesContainer.innerHTML = '';
}

async function loadImageFromFile(file){
  if (!file) return;
  const blobUrl = URL.createObjectURL(file);
  const img = new Image();
  img.onload = async () => { resetUIForImage(img); if (canvas.width>0 && canvas.height>0) { await analyzeOnce(canvas); } };
  img.onerror = () => setStatus('Görsel yüklenemedi.');
  img.src = blobUrl;
}

fileInput.addEventListener('change', async (e)=>{
  const file = e.target.files && e.target.files[0];
  await loadImageFromFile(file);
});

// Drag & Drop
;['dragenter','dragover','dragleave','drop'].forEach(ev=>{
  dropZone.addEventListener(ev, (e)=>{ e.preventDefault(); e.stopPropagation(); });
});
;['dragenter','dragover'].forEach(ev=>{
  dropZone.addEventListener(ev, ()=>{ dropZone.classList.add('border-blue-500'); });
});
;['dragleave','drop'].forEach(ev=>{
  dropZone.addEventListener(ev, ()=>{ dropZone.classList.remove('border-blue-500'); });
});
dropZone.addEventListener('drop', (e)=>{
  const dt = e.dataTransfer; const file = dt && dt.files && dt.files[0];
  if (file) loadImageFromFile(file);
});

function pick(anns, key, idx=0){ return anns[key] && anns[key][idx] ? {x:anns[key][idx][0], y:anns[key][idx][1]} : null; }

function computeMetrics(pred){
  const ann = pred.annotations || {};
  const kpts = pred.scaledMesh.map(([x,y])=>({x,y}));
  const leftOuter = pick(ann,'leftEyeOuterCorner') || pick(ann,'leftEyeLower0',0) || pick(ann,'leftEyeUpper0',0);
  const rightOuter = pick(ann,'rightEyeOuterCorner') || pick(ann,'rightEyeLower0',0) || pick(ann,'rightEyeUpper0',0);
  const leftInner = pick(ann,'leftEyeInnerCorner') || pick(ann,'leftEyeLower0',6) || pick(ann,'leftEyeUpper0',6);
  const rightInner = pick(ann,'rightEyeInnerCorner') || pick(ann,'rightEyeLower0',6) || pick(ann,'rightEyeUpper0',6);
  const leftCheek = pick(ann,'leftCheek') || pick(ann,'silhouette',234);
  const rightCheek = pick(ann,'rightCheek') || pick(ann,'silhouette',454);
  const chin = pick(ann,'lipsLowerInner',5) || pick(ann,'silhouette',152);
  const topFace = pick(ann,'foreheadGlabella') || pick(ann,'silhouette',10);
  const noseTip = pick(ann,'noseTip') || pick(ann,'midwayBetweenEyes') || pick(ann,'noseBottom',0);
  const midEyes = pick(ann,'midwayBetweenEyes') || (leftOuter&&rightOuter? {x:(leftOuter.x+rightOuter.x)/2, y:(leftOuter.y+rightOuter.y)/2}:null);

  let faceWidth = null, faceHeight = null, eyeDist = null, noseLen = null;
  if (leftCheek && rightCheek) faceWidth = dist(leftCheek,rightCheek);
  if (topFace && chin) faceHeight = dist(topFace,chin);
  if (leftOuter && rightOuter) eyeDist = dist(leftOuter,rightOuter);
  if (noseTip && midEyes) noseLen = dist(noseTip, midEyes);

  // Mouth width via lips points spread
  let mouthWidth = null;
  if (ann.lipsUpperOuter || ann.lipsLowerOuter){
    const pts = [...(ann.lipsUpperOuter||[]), ...(ann.lipsLowerOuter||[])];
    if (pts.length){
      let minx=1e9, maxx=-1e9; pts.forEach(v=>{ minx=Math.min(minx,v[0]); maxx=Math.max(maxx,v[0]); });
      mouthWidth = Math.max(0, maxx-minx);
    }
  }

  // Interpupillary distance using iris centers or mid points, iris diameters
  let ipd = null; let leftIrisDiam=null; let rightIrisDiam=null;
  if (ann.leftEyeIris && ann.rightEyeIris){
    const center = arr=>{
      let sx=0, sy=0; arr.forEach(v=>{ sx+=v[0]; sy+=v[1]; }); return {x:sx/arr.length, y:sy/arr.length};
    };
    const lc=center(ann.leftEyeIris), rc=center(ann.rightEyeIris); ipd = dist(lc,rc);
    // approximate iris diameter as max pairwise distance among iris points
    function irisDiam(arr){ let d=0; for(let i=0;i<arr.length;i++){ for(let j=i+1;j<arr.length;j++){ const a={x:arr[i][0],y:arr[i][1]}, b={x:arr[j][0],y:arr[j][1]}; d=Math.max(d, dist(a,b)); } } return d; }
    leftIrisDiam = irisDiam(ann.leftEyeIris);
    rightIrisDiam = irisDiam(ann.rightEyeIris);
  } else if (leftInner && rightInner) { ipd = dist(leftInner,rightInner); }

  // Eye aspect ratio (EAR) estimate
  function ear(upper, lower, inner, outer){
    if (!upper || !lower || !inner || !outer) return null;
    const sampleIdx = [1,3,5];
    let vSum=0, n=0;
    sampleIdx.forEach(i=>{
      const u=upper[i]||upper[0]; const l=lower[i]||lower[0];
      const up={x:u[0],y:u[1]}, lo={x:l[0],y:l[1]}; vSum += dist(up,lo); n++;
    });
    const w = dist({x:inner.x,y:inner.y},{x:outer.x,y:outer.y});
    if (!w) return null; return (vSum/n)/w;
  }
  const leftEAR = ear(ann.leftEyeUpper0, ann.leftEyeLower0, leftInner, leftOuter);
  const rightEAR = ear(ann.rightEyeUpper0, ann.rightEyeLower0, rightInner, rightOuter);

  // symmetry
  let symmetryScore = 0; let symVal = '-';
  if (kpts && kpts.length){
    const xs = kpts.map(p=>p.x).sort((a,b)=>a-b);
    const midx = xs[Math.floor(xs.length/2)];
    let total=0, n=0;
    for (let i=0;i<kpts.length;i+=20){
      const q = kpts[i];
      const rx = 2*midx - q.x;
      let best=null, bd=1e9;
      for (let j=0;j<kpts.length;j+=20){ const r=kpts[j]; const d=(r.x-rx)*(r.x-rx)+(r.y-q.y)*(r.y-q.y); if(d<bd){bd=d; best=r;} }
      if (best){ total += Math.sqrt(bd); n++; }
    }
    const norm = Math.sqrt(faceWidth||1)+1e-6;
    const avg = n? (total/n)/norm : 1;
    symmetryScore = clamp(1 - avg, 0, 1);
    symVal = (symmetryScore*100).toFixed(1)+'%';
  }

  let ratioScore=0, eyeScore=0, noseScore=0, mouthScore=0, ipdScore=0, earScore=0, irisEyeScore=0, irisFaceScore=0;
  let ratioVal='-', eyeVal='-', noseVal='-', mouthVal='-', ipdVal='-', earVal='-', irisEyeVal='-', irisFaceVal='-';
  // head tilt from eye line
  let tiltDeg = null;
  if (leftOuter && rightOuter){ const dy = rightOuter.y-leftOuter.y; const dx = rightOuter.x-leftOuter.x; tiltDeg = Math.atan2(dy,dx)*180/Math.PI; }
  const prof = getActiveProfile();
  const T = prof.targets; // targets
  const tol = { ratio:0.5, eye:0.2, nose:0.15, mouth:0.15, ipd:0.12, ear:0.12, irisEye:0.12, irisFace:0.05 };
  if (faceWidth && faceHeight){ const v=faceHeight/faceWidth; ratioVal=v.toFixed(3); ratioScore=closenessScore(v,T.ratio,tol.ratio); }
  if (eyeDist && faceWidth){ const v=eyeDist/faceWidth; eyeVal=v.toFixed(3); eyeScore=closenessScore(v,T.eye,tol.eye); }
  if (noseLen && faceHeight){ const v=noseLen/faceHeight; noseVal=v.toFixed(3); noseScore=closenessScore(v,T.nose,tol.nose); }
  if (mouthWidth && faceWidth){ const v=mouthWidth/faceWidth; mouthVal=v.toFixed(3); mouthScore=closenessScore(v,T.mouth,tol.mouth); }
  if (ipd && faceWidth){ const v=ipd/faceWidth; ipdVal=v.toFixed(3); ipdScore=closenessScore(v,T.ipd,tol.ipd); }
  if (leftEAR && rightEAR){ const v=(leftEAR+rightEAR)/2; earVal=v.toFixed(3); earScore=closenessScore(v,T.ear,tol.ear); }
  // Iris diameter ratios
  if (leftIrisDiam && rightIrisDiam && leftOuter && rightOuter){
    const irisAvg = (leftIrisDiam + rightIrisDiam)/2;
    const eyeW = dist(leftOuter, rightOuter);
    if (eyeW){ const v = irisAvg/eyeW; irisEyeVal = v.toFixed(3); irisEyeScore = closenessScore(v, T.irisEye, tol.irisEye); }
    if (faceWidth){ const vf = irisAvg/faceWidth; irisFaceVal = vf.toFixed(3); irisFaceScore = closenessScore(vf, T.irisFace, tol.irisFace); }
  }

  const Wraw = prof.weights;
  const wSum = (Wraw.ratio||0)+(Wraw.eye||0)+(Wraw.nose||0)+(Wraw.sym||0)+(Wraw.mouth||0)+(Wraw.ipd||0)+(Wraw.ear||0)+(Wraw.irisEye||0)+(Wraw.irisFace||0) || 1;
  const W = { ratio:(Wraw.ratio||0)/wSum, eye:(Wraw.eye||0)/wSum, nose:(Wraw.nose||0)/wSum, sym:(Wraw.sym||0)/wSum, mouth:(Wraw.mouth||0)/wSum, ipd:(Wraw.ipd||0)/wSum, ear:(Wraw.ear||0)/wSum, irisEye:(Wraw.irisEye||0)/wSum, irisFace:(Wraw.irisFace||0)/wSum };
  const symScoreAdj = closenessScore(symmetryScore, 1.0, 0.5);
  const baseScore = 100*((ratioScore||0)*W.ratio + (eyeScore||0)*W.eye + (noseScore||0)*W.nose + (symScoreAdj||0)*W.sym + (mouthScore||0)*W.mouth + (ipdScore||0)*W.ipd + (earScore||0)*W.ear + (irisEyeScore||0)*W.irisEye + (irisFaceScore||0)*W.irisFace);

  return { ann, kpts, leftOuter, rightOuter, leftCheek, rightCheek, chin, topFace, noseTip, midEyes, faceWidth, faceHeight, eyeDist, noseLen, ratioVal, eyeVal, noseVal, symVal, baseScore, mouthVal, ipdVal, earVal, leftEAR, rightEAR, irisEyeVal, irisFaceVal, tiltDeg };
}

function drawPrediction(input, pred, metrics, idx, highlight){
  const kpts = metrics.kpts;
  const p = pred;
  // base image/frame already drawn by caller
  ctx.save();
  const color = highlight ? 'rgba(59,130,246,0.95)' : 'rgba(59,130,246,0.6)';
  for (let i=0;i<kpts.length;i+=1){ drawCircle(kpts[i], 1.2, color); }
  // safe bounding box access (supports both [x,y] and [[x,y]] styles)
  if (p.boundingBox && p.boundingBox.topLeft && p.boundingBox.bottomRight){
    let tlRaw = p.boundingBox.topLeft, brRaw = p.boundingBox.bottomRight;
    if (Array.isArray(tlRaw[0])) { tlRaw = tlRaw[0]; brRaw = brRaw[0]; }
    const tl = {x:tlRaw[0], y:tlRaw[1]};
    const br = {x:brRaw[0], y:brRaw[1]};
    ctx.strokeStyle= highlight ? 'rgba(34,197,94,0.95)' : 'rgba(34,197,94,0.6)'; ctx.lineWidth=2; ctx.strokeRect(tl.x, tl.y, br.x-tl.x, br.y-tl.y);
    ctx.fillStyle='rgba(2,6,23,.75)';
    ctx.fillRect(tl.x, tl.y-28, 120, 24);
    ctx.fillStyle='#e6edf3'; ctx.font='700 14px ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto';
    ctx.fillText(`#${idx+1} Skor: ${Math.round(metrics.score)}`, tl.x+6, tl.y-10);
  }
  // guide lines
  if (metrics.leftOuter && metrics.rightOuter){ drawLine(metrics.leftOuter,metrics.rightOuter,'rgba(250,204,21,0.9)',2); }
  if (metrics.leftCheek && metrics.rightCheek){ drawLine(metrics.leftCheek,metrics.rightCheek,'rgba(34,197,94,0.9)',2); }
  if (metrics.topFace && metrics.chin){ drawLine(metrics.topFace,metrics.chin,'rgba(244,63,94,0.9)',2); }
  if (metrics.noseTip && metrics.midEyes){ drawLine(metrics.noseTip, metrics.midEyes,'rgba(96,165,250,0.9)',2); }
  // contours
  function poly(arr, col){ if(!arr||!arr.length) return; ctx.beginPath(); ctx.strokeStyle=col; ctx.lineWidth=1; ctx.moveTo(arr[0][0],arr[0][1]); for(let i=1;i<arr.length;i++){ ctx.lineTo(arr[i][0],arr[i][1]); } ctx.stroke(); }
  const a = metrics.ann;
  poly(a.silhouette,'rgba(148,163,184,0.5)');
  poly(a.leftEyebrowUpper,'rgba(251,191,36,0.8)'); poly(a.rightEyebrowUpper,'rgba(251,191,36,0.8)');
  poly(a.leftEyeUpper0,'rgba(147,197,253,0.9)'); poly(a.leftEyeLower0,'rgba(147,197,253,0.6)');
  poly(a.rightEyeUpper0,'rgba(147,197,253,0.9)'); poly(a.rightEyeLower0,'rgba(147,197,253,0.6)');
  poly(a.lipsUpperOuter,'rgba(244,63,94,0.9)'); poly(a.lipsLowerOuter,'rgba(244,63,94,0.6)');
  // facial thirds and golden ratio guides within bbox if available
  if (p.boundingBox && p.boundingBox.topLeft && p.boundingBox.bottomRight){
    let tlRaw = p.boundingBox.topLeft, brRaw = p.boundingBox.bottomRight;
    if (Array.isArray(tlRaw[0])) { tlRaw = tlRaw[0]; brRaw = brRaw[0]; }
    const tl = {x:tlRaw[0], y:tlRaw[1]};
    const br = {x:brRaw[0], y:brRaw[1]};
    const w = br.x - tl.x, h = br.y - tl.y;
    // thirds
    const y1 = tl.y + h/3, y2 = tl.y + 2*h/3;
    ctx.strokeStyle='rgba(59,130,246,0.35)'; ctx.lineWidth=1; ctx.setLineDash([6,6]);
    drawLine({x:tl.x,y:y1},{x:br.x,y:y1},'rgba(59,130,246,0.35)',1);
    drawLine({x:tl.x,y:y2},{x:br.x,y:y2},'rgba(59,130,246,0.35)',1);
    // golden ratio
    const phi = 0.618; const gy1 = tl.y + h*phi; const gy2 = tl.y + h*(1-phi);
    drawLine({x:tl.x,y:gy1},{x:br.x,y:gy1},'rgba(250,204,21,0.35)',1);
    drawLine({x:tl.x,y:gy2},{x:br.x,y:gy2},'rgba(250,204,21,0.35)',1);
    ctx.setLineDash([]);
  }
  ctx.restore();
}

function renderFaceList(preds, metricsList){
  facesContainer.innerHTML = '';
  preds.forEach((p, i)=>{
    const btn = document.createElement('button');
    btn.className = 'w-full text-left metric hover:bg-gray-800';
    btn.innerHTML = `<div class="flex items-center justify-between"><div class="font-semibold">Yüz #${i+1}</div><div>${Math.round(metricsList[i].finalScore||metricsList[i].baseScore||0)}</div></div>`;
    btn.addEventListener('click', ()=>{ selectedFace = i; updateMetricsUI(metricsList[i]); drawAll(preds, metricsList); });
    facesContainer.appendChild(btn);
  });
}

function updateMetricsUI(m){
  ratioMetric.textContent = m.ratioVal === '-' ? '-' : m.ratioVal + ' (hedef 1.618)';
  eyeMetric.textContent = m.eyeVal === '-' ? '-' : m.eyeVal + ' (hedef ~0.46)';
  noseMetric.textContent = m.noseVal === '-' ? '-' : m.noseVal + ' (hedef ~0.33)';
  symmetryMetric.textContent = m.symVal;
  mouthMetric.textContent = m.mouthVal==='-'?'-': m.mouthVal + ' (hedef ~0.36)';
  ipdMetric.textContent = m.ipdVal==='-'?'-': m.ipdVal + ' (hedef ~0.32)';
  earMetric.textContent = (m.leftEAR&&m.rightEAR)? `${m.leftEAR.toFixed(3)} / ${m.rightEAR.toFixed(3)}` : '-';
  irisEyeMetric.textContent = m.irisEyeVal==='-'?'-': m.irisEyeVal + ' (hedef ~0.32)';
  irisFaceMetric.textContent = m.irisFaceVal==='-'?'-': m.irisFaceVal + ' (hedef ~0.095)';
  blurMetric.textContent = lastQuality.blurVar==null? '-' : `${Math.round(lastQuality.blurVar)} (skor ${(lastQuality.blurScore*100|0)}/100)`;
  tiltMetric.textContent = (m.tiltDeg==null)? '-' : `${Math.abs(m.tiltDeg).toFixed(1)}°`;
  scoreBadge.classList.remove('hidden');
  scoreText.textContent = Math.round(m.finalScore||m.baseScore||0);
}

function drawAll(preds, metricsList, baseInput){
  const input = baseInput || imgBitmap || video;
  if (!input) return;
  const isVideo = input === video;
  const mirrored = isVideo && mirrorChk && mirrorChk.checked;
  ctx.save();
  if (mirrored){ ctx.translate(canvas.width, 0); ctx.scale(-1, 1); }
  ctx.drawImage(input,0,0,canvas.width,canvas.height);
  preds.forEach((p,i)=> drawPrediction(input, p, metricsList[i], i, i===selectedFace));
  ctx.restore();
  // corner score
  const s = Math.round(metricsList[selectedFace]?.finalScore || metricsList[selectedFace]?.baseScore || 0);
  ctx.save();
  ctx.fillStyle='rgba(2,6,23,.75)';
  ctx.fillRect(10,10,160,44);
  ctx.strokeStyle='rgba(148,163,184,.35)';
  ctx.lineWidth=1; ctx.strokeRect(10.5,10.5,159,43);
  ctx.fillStyle='#e6edf3';
  ctx.font='700 26px ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto';
  ctx.fillText('Skor: '+s, 22, 40);
  ctx.restore();
}

async function analyzeOnce(input){
  await ensureModels();
  setStatus('Analiz ediliyor...');
  if (!input || (input===canvas && (canvas.width===0 || canvas.height===0))) {
    setStatus('Görsel yüklenmedi.');
    return [];
  }
  // Preprocess input to enhanced canvas
  const enhanced = await enhanceInput(input);
  let useInput = enhanced || input;
  let predictions = [];
  // try facemesh first if available
  if (model){
    try{
      predictions = await model.estimateFaces({ input: useInput, flipHorizontal: (input===video && mirrorChk && mirrorChk.checked), predictIrises: true });
    }catch(err){ predictions = []; }
  }
  // fallback to blazeface if no predictions
  let blazePreds = [];
  if ((!predictions || predictions.length===0) && blazeModel){
    try{
      blazePreds = await blazeModel.estimateFaces(useInput, false);
    }catch(e){ blazePreds = []; }
  }
  lastPredictions = predictions || [];
  if ((!predictions || predictions.length===0) && (!blazePreds || blazePreds.length===0)){
    await tryInitOpenCV();
    // TF başarısız: Haar ile deneriz
    if (cvReady && faceClassifier){
      try{
        // draw base
        ctx.drawImage(input,0,0,canvas.width,canvas.height);
        const src = cv.imread(canvas);
        let gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
        let faces = new cv.RectVector(); let msize = new cv.Size(0,0);
        faceClassifier.detectMultiScale(gray, faces, 1.1, 3, 0, msize, msize);
        for (let i=0;i<faces.size();i++){
          const r = faces.get(i);
          ctx.strokeStyle='rgba(234,179,8,0.95)'; ctx.lineWidth=3; ctx.strokeRect(r.x, r.y, r.width, r.height);
        }
        src.delete(); gray.delete(); faces.delete();
        setStatus(`TF yok, Haar ile ${faces.size()} yüz`);
      }catch(e){ setStatus('Yüz bulunamadı.'); }
    } else {
      setStatus('Yüz bulunamadı.');
    }
    facesContainer.innerHTML = '';
    return [];
  }
  const metricsList = (predictions && predictions.length>0)
    ? predictions.map(p=>computeMetrics(p))
    : blazePreds.map(p=>computeMetricsFromBlaze(p));
  // quality: blur (global) and tilt (per face)
  try{ await tryInitOpenCV(); }catch(e){}
  if (cvReady){
    try{
      // compute blur variance via Laplacian
      ctx.drawImage(input,0,0,canvas.width,canvas.height);
      const src = cv.imread(canvas);
      let gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
      let lap = new cv.Mat(); cv.Laplacian(gray, lap, cv.CV_64F);
      let mean = new cv.Mat(); let std = new cv.Mat();
      cv.meanStdDev(lap, mean, std);
      const variance = Math.pow(std.doubleAt(0,0),2);
      lastQuality.blurVar = variance;
      // map var->score in [0,1]
      const minV=100, maxV=1200; const sc = (variance - minV)/(maxV-minV); lastQuality.blurScore = clamp(sc,0,1);
      src.delete(); gray.delete(); lap.delete(); mean.delete(); std.delete();
    }catch(e){ lastQuality.blurVar=null; lastQuality.blurScore=null; }
  } else { lastQuality.blurVar=null; lastQuality.blurScore=null; }
  // final score with penalty
  metricsList.forEach(m=>{
    const tiltS = (m.tiltDeg==null)? 1 : closenessScore(Math.abs(m.tiltDeg), 0, 8);
    const blurS = (lastQuality.blurScore==null)? 1 : lastQuality.blurScore;
    const penalty = 0.6 + 0.4*Math.min(tiltS, blurS);
    m.finalScore = Math.max(0, Math.min(100, (m.baseScore||0) * penalty));
  });
  selectedFace = Math.min(selectedFace, metricsList.length-1);
  renderFaceList(predictions, metricsList);
  updateMetricsUI(metricsList[selectedFace]);
  drawAll(predictions, metricsList, input);
  setStatus(`${predictions.length} yüz analiz edildi`);
  window.__lastMetricsList = metricsList;
  return metricsList;
}

analyzeBtn.addEventListener('click', async ()=>{
  if (canvas.width===0 || canvas.height===0) { setStatus('Önce bir görsel yükleyin.'); return; }
  analyzeBtn.disabled = true;
  try { await analyzeOnce(canvas); } finally { analyzeBtn.disabled = false; }
});

// Webcam
startCamBtn.addEventListener('click', async ()=>{
  try{
    await ensureModel();
    mediaStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
    video.srcObject = mediaStream;
    await video.play();
    live = true;
    analyzeBtn.disabled = true; fileInput.disabled = true;
    startCamBtn.disabled = true; stopCamBtn.disabled = false;
    scoreBadge.classList.add('hidden');
    video.classList.remove('hidden');
    
    canvas.width = video.videoWidth || 640; canvas.height = video.videoHeight || 480;
    loopLive();
  }catch(err){ setStatus('Kamera başlatılamadı: '+ (err && err.message ? err.message : err)); }
});

stopCamBtn.addEventListener('click', ()=>{
  live = false;
  if (rafId) cancelAnimationFrame(rafId);
  if (mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream = null; }
  video.pause(); video.srcObject=null; video.classList.add('hidden');
  startCamBtn.disabled = false; stopCamBtn.disabled = true;
  fileInput.disabled = false; analyzeBtn.disabled = !imgBitmap;
});

let lastTs = 0; const targetMs = 1000/15; // 15 FPS throttle
async function loopLive(ts){
  if (!live) return;
  rafId = requestAnimationFrame(loopLive);
  if (ts - lastTs < targetMs) return; lastTs = ts;
  if (video.readyState < 2) return;
  try{ await analyzeOnce(video); } catch(e){ /* ignore frame errors */ }
}

ensureModel().catch(()=>{});
loadProfiles();

// Keyboard shortcuts
window.addEventListener('keydown', (e)=>{
  if (e.ctrlKey && (e.key==='o' || e.key==='O')){ e.preventDefault(); fileInput.click(); return; }
  if (e.code==='Space'){
    e.preventDefault();
    if (live) { stopCamBtn.click(); } else { startCamBtn.click(); }
    return;
  }
  if (e.key==='a' || e.key==='A'){
    if (!live && imgBitmap) analyzeBtn.click();
    return;
  }
});
</script>
</body>
</html>
